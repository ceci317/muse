<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DashScope TTS è°ƒè¯•å·¥å…·</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .container { max-width: 800px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #333; border-radius: 8px; background: #2a2a2a; }
        .error { color: #ff6b6b; }
        .success { color: #51cf66; }
        .warning { color: #ffd43b; }
        .info { color: #74c0fc; }
        input, textarea, button { padding: 10px; margin: 5px; border: 1px solid #555; background: #333; color: #fff; border-radius: 4px; }
        button { cursor: pointer; background: #4c6ef5; }
        button:hover { background: #364fc7; }
        .log { background: #000; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 4px; }
        .test-result.success { background: #2b8a3e; }
        .test-result.error { background: #c92a2a; }
        .test-result.warning { background: #f08c00; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ DashScope TTS è°ƒè¯•å·¥å…·</h1>
        
        <!-- API å¯†é’¥é…ç½® -->
        <div class="section">
            <h2>1. API å¯†é’¥é…ç½®</h2>
            <input type="password" id="api-key" placeholder="è¾“å…¥ DashScope API å¯†é’¥" style="width: 400px;">
            <button onclick="validateApiKey()">éªŒè¯å¯†é’¥</button>
            <div id="key-status" class="test-result" style="display: none;"></div>
        </div>

        <!-- ç½‘ç»œè¿æ¥æµ‹è¯• -->
        <div class="section">
            <h2>2. ç½‘ç»œè¿æ¥æµ‹è¯•</h2>
            <button onclick="testNetworkConnection()">æµ‹è¯•ç½‘ç»œè¿æ¥</button>
            <div id="network-status" class="test-result" style="display: none;"></div>
        </div>

        <!-- API ç«¯ç‚¹æµ‹è¯• -->
        <div class="section">
            <h2>3. API ç«¯ç‚¹æµ‹è¯•</h2>
            <button onclick="testApiEndpoint()">æµ‹è¯• API ç«¯ç‚¹</button>
            <div id="endpoint-status" class="test-result" style="display: none;"></div>
        </div>

        <!-- TTS å‚æ•°æµ‹è¯• -->
        <div class="section">
            <h2>4. TTS å‚æ•°æµ‹è¯•</h2>
            <div>
                <label>æ–‡æœ¬å†…å®¹ï¼š</label><br>
                <textarea id="test-text" rows="3" style="width: 100%;">ä½ å¥½ï¼Œè¿™æ˜¯ä¸€ä¸ªæµ‹è¯•</textarea>
            </div>
            <div>
                <label>éŸ³è‰²é€‰æ‹©ï¼š</label>
                <select id="voice-select" style="padding: 10px; margin: 5px;">
                    <option value="Cherry">Cherry (å¥³å£°)</option>
                    <option value="Siming">Siming (ç”·å£°)</option>
                    <option value="Zhidar">Zhidar (ç”·å£°)</option>
                    <option value="Ethan">Ethan (ç”·å£°)</option>
                    <option value="Dylan">Dylan (ç”·å£°)</option>
                </select>
            </div>
            <button onclick="testTTSRequest()">æµ‹è¯• TTS è¯·æ±‚</button>
            <div id="tts-status" class="test-result" style="display: none;"></div>
        </div>

        <!-- å®Œæ•´æµç¨‹æµ‹è¯• -->
        <div class="section">
            <h2>5. å®Œæ•´æµç¨‹æµ‹è¯•</h2>
            <button onclick="runFullTest()">è¿è¡Œå®Œæ•´æµ‹è¯•</button>
            <div id="full-test-status" class="test-result" style="display: none;"></div>
        </div>

        <!-- é”™è¯¯æ—¥å¿— -->
        <div class="section">
            <h2>6. è¯¦ç»†æ—¥å¿—</h2>
            <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
            <div id="debug-log" class="log"></div>
        </div>
    </div>

    <script>
        let debugLog = document.getElementById('debug-log');
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
            debugLog.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function clearLog() {
            debugLog.innerHTML = '';
        }

        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.style.display = 'block';
            element.className = `test-result ${type}`;
            element.textContent = message;
        }

        // 1. éªŒè¯ API å¯†é’¥æ ¼å¼
        function validateApiKey() {
            const apiKey = document.getElementById('api-key').value;
            
            if (!apiKey) {
                showResult('key-status', 'âŒ è¯·è¾“å…¥ API å¯†é’¥', 'error');
                log('API å¯†é’¥ä¸ºç©º', 'error');
                return false;
            }

            // åŸºæœ¬æ ¼å¼æ£€æŸ¥
            if (apiKey.length < 20) {
                showResult('key-status', 'âŒ API å¯†é’¥é•¿åº¦ä¸è¶³', 'error');
                log('API å¯†é’¥é•¿åº¦ä¸è¶³', 'error');
                return false;
            }

            if (/\s/.test(apiKey)) {
                showResult('key-status', 'âŒ API å¯†é’¥åŒ…å«ç©ºæ ¼', 'error');
                log('API å¯†é’¥åŒ…å«ç©ºæ ¼', 'error');
                return false;
            }

            showResult('key-status', 'âœ… API å¯†é’¥æ ¼å¼æ­£ç¡®', 'success');
            log('API å¯†é’¥æ ¼å¼éªŒè¯é€šè¿‡', 'success');
            return true;
        }

        // 2. æµ‹è¯•ç½‘ç»œè¿æ¥
        async function testNetworkConnection() {
            log('å¼€å§‹æµ‹è¯•ç½‘ç»œè¿æ¥...', 'info');
            
            try {
                // æµ‹è¯•åŸºæœ¬ç½‘ç»œè¿æ¥
                const response = await fetch('https://www.baidu.com', { 
                    method: 'HEAD', 
                    mode: 'no-cors',
                    cache: 'no-cache'
                });
                
                showResult('network-status', 'âœ… ç½‘ç»œè¿æ¥æ­£å¸¸', 'success');
                log('ç½‘ç»œè¿æ¥æµ‹è¯•é€šè¿‡', 'success');
                
                // æµ‹è¯• DashScope åŸŸåè§£æ
                try {
                    await fetch('https://dashscope.aliyuncs.com', { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache'
                    });
                    log('DashScope åŸŸåè§£ææ­£å¸¸', 'success');
                } catch (e) {
                    log('DashScope åŸŸåè§£æå¯èƒ½æœ‰é—®é¢˜: ' + e.message, 'warning');
                }
                
            } catch (error) {
                showResult('network-status', 'âŒ ç½‘ç»œè¿æ¥å¤±è´¥: ' + error.message, 'error');
                log('ç½‘ç»œè¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–æ­£ç¡®çš„ API åŸºç¡€ URL
        function getApiBaseUrl() {
            // å¦‚æœåœ¨æœ¬åœ°å¼€å‘ç¯å¢ƒï¼Œä½¿ç”¨ä»£ç†æœåŠ¡å™¨
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                return 'http://localhost:3001/api/dashscope/api/v1';
            }
            return 'https://dashscope.aliyuncs.com/api/v1';
        }

        // 3. æµ‹è¯• API ç«¯ç‚¹
        async function testApiEndpoint() {
            const apiKey = document.getElementById('api-key').value;
            
            if (!validateApiKey()) {
                showResult('endpoint-status', 'âŒ è¯·å…ˆé…ç½®æœ‰æ•ˆçš„ API å¯†é’¥', 'error');
                return;
            }

            log('å¼€å§‹æµ‹è¯• API ç«¯ç‚¹...', 'info');

            try {
                const baseUrl = getApiBaseUrl();
                const apiUrl = `${baseUrl}/services/aigc/multimodal-generation/generation`;
                
                log(`ä½¿ç”¨ API ç«¯ç‚¹: ${apiUrl}`, 'info');
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'qwen3-tts-flash',
                        input: {
                            text: 'æµ‹è¯•'
                        },
                        parameters: {
                            voice: 'Cherry',
                            language_type: 'Chinese',
                            stream: false
                        }
                    })
                });

                log(`API å“åº”çŠ¶æ€: ${response.status}`, 'info');
                log(`API å“åº”å¤´: ${JSON.stringify([...response.headers.entries()])}`, 'info');

                if (response.ok) {
                    const data = await response.json();
                    log(`API å“åº”æ•°æ®: ${JSON.stringify(data, null, 2)}`, 'info');
                    showResult('endpoint-status', 'âœ… API ç«¯ç‚¹è¿æ¥æˆåŠŸ', 'success');
                } else {
                    const errorText = await response.text();
                    log(`API é”™è¯¯å“åº”: ${errorText}`, 'error');
                    
                    if (response.status === 401) {
                        showResult('endpoint-status', 'âŒ API å¯†é’¥æ— æ•ˆæˆ–å·²è¿‡æœŸ', 'error');
                    } else if (response.status === 403) {
                        showResult('endpoint-status', 'âŒ API å¯†é’¥æƒé™ä¸è¶³', 'error');
                    } else if (response.status === 429) {
                        showResult('endpoint-status', 'âš ï¸ API è°ƒç”¨é¢‘ç‡é™åˆ¶', 'warning');
                    } else {
                        showResult('endpoint-status', `âŒ API é”™è¯¯ (${response.status}): ${errorText}`, 'error');
                    }
                }

            } catch (error) {
                log(`API ç«¯ç‚¹æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                
                if (error.message.includes('Failed to fetch')) {
                    showResult('endpoint-status', 'âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œå¯èƒ½æ˜¯ CORS é—®é¢˜æˆ–ç½‘ç»œè¿æ¥é—®é¢˜', 'error');
                } else {
                    showResult('endpoint-status', `âŒ API ç«¯ç‚¹æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }
            }
        }

        // 4. æµ‹è¯• TTS è¯·æ±‚
        async function testTTSRequest() {
            const apiKey = document.getElementById('api-key').value;
            const text = document.getElementById('test-text').value;
            const voice = document.getElementById('voice-select').value;

            if (!validateApiKey()) {
                showResult('tts-status', 'âŒ è¯·å…ˆé…ç½®æœ‰æ•ˆçš„ API å¯†é’¥', 'error');
                return;
            }

            if (!text.trim()) {
                showResult('tts-status', 'âŒ è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'error');
                return;
            }

            log(`å¼€å§‹æµ‹è¯• TTS è¯·æ±‚ - æ–‡æœ¬: "${text}", éŸ³è‰²: ${voice}`, 'info');

            try {
                const payload = {
                    model: 'qwen3-tts-flash',
                    input: {
                        text: text
                    },
                    parameters: {
                        voice: voice,
                        language_type: 'Chinese',
                        stream: false
                    }
                };

                const baseUrl = getApiBaseUrl();
                const apiUrl = `${baseUrl}/services/aigc/multimodal-generation/generation`;
                
                log(`ä½¿ç”¨ API ç«¯ç‚¹: ${apiUrl}`, 'info');
                log(`è¯·æ±‚è½½è·: ${JSON.stringify(payload, null, 2)}`, 'info');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                log(`TTS å“åº”çŠ¶æ€: ${response.status}`, 'info');

                if (response.ok) {
                    const data = await response.json();
                    log(`TTS å“åº”æ•°æ®: ${JSON.stringify(data, null, 2)}`, 'info');

                    if (data.output && data.output.audio_url) {
                        showResult('tts-status', 'âœ… TTS è¯·æ±‚æˆåŠŸï¼Œæ­£åœ¨æ’­æ”¾éŸ³é¢‘...', 'success');
                        
                        // å°è¯•æ’­æ”¾éŸ³é¢‘
                        try {
                            const audio = new Audio(data.output.audio_url);
                            await audio.play();
                            log('éŸ³é¢‘æ’­æ”¾æˆåŠŸ', 'success');
                        } catch (playError) {
                            log(`éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${playError.message}`, 'warning');
                            showResult('tts-status', 'âš ï¸ TTS è¯·æ±‚æˆåŠŸï¼Œä½†éŸ³é¢‘æ’­æ”¾å¤±è´¥', 'warning');
                        }
                    } else if (data.output && data.output.audio) {
                        log('æ”¶åˆ°éŸ³é¢‘æ•°æ®', 'success');
                        log('éŸ³é¢‘æ•°æ®ç±»å‹: ' + typeof data.output.audio, 'info');
                        log('éŸ³é¢‘æ•°æ®ç»“æ„: ' + JSON.stringify(data.output.audio).substring(0, 200) + '...', 'info');
                        
                        if (typeof data.output.audio === 'object' && data.output.audio.url) {
                            // éŸ³é¢‘å¯¹è±¡åŒ…å« URL
                            showResult('tts-status', 'âœ… TTS è¯·æ±‚æˆåŠŸï¼Œæ­£åœ¨æ’­æ”¾éŸ³é¢‘...', 'success');
                            log('ä½¿ç”¨éŸ³é¢‘å¯¹è±¡ä¸­çš„ URL: ' + data.output.audio.url, 'info');
                            
                            try {
                                const audio = new Audio(data.output.audio.url);
                                
                                audio.onloadeddata = () => log('éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆ', 'info');
                                audio.oncanplay = () => log('éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾', 'info');
                                audio.onplay = () => log('éŸ³é¢‘å¼€å§‹æ’­æ”¾', 'success');
                                audio.onended = () => log('éŸ³é¢‘æ’­æ”¾ç»“æŸ', 'success');
                                audio.onerror = (e) => {
                                    log('éŸ³é¢‘æ’­æ”¾é”™è¯¯: ' + (audio.error ? audio.error.message : 'æœªçŸ¥é”™è¯¯'), 'error');
                                };
                                
                                await audio.play();
                                log('éŸ³é¢‘æ’­æ”¾æˆåŠŸ', 'success');
                            } catch (playError) {
                                log(`éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${playError.message}`, 'error');
                                showResult('tts-status', 'âš ï¸ TTS è¯·æ±‚æˆåŠŸï¼Œä½†éŸ³é¢‘æ’­æ”¾å¤±è´¥', 'warning');
                            }
                        } else if (typeof data.output.audio === 'string') {
                            // Base64 éŸ³é¢‘æ•°æ®
                            showResult('tts-status', 'âœ… TTS è¯·æ±‚æˆåŠŸ (Base64 æ ¼å¼)ï¼Œæ­£åœ¨æ’­æ”¾...', 'success');
                            
                            // å°è¯•æ’­æ”¾ Base64 éŸ³é¢‘
                            try {
                                // å¤„ç†ä¸åŒç±»å‹çš„éŸ³é¢‘æ•°æ®
                                let cleanBase64;
                                if (typeof data.output.audio === 'string') {
                                    cleanBase64 = data.output.audio.replace(/^data:audio\/[^;]+;base64,/, '');
                                } else if (Array.isArray(data.output.audio)) {
                                    cleanBase64 = data.output.audio.join('');
                                } else {
                                    cleanBase64 = String(data.output.audio);
                                }
                                
                                log('å¤„ç†éŸ³é¢‘æ•°æ®ï¼Œç±»å‹: ' + typeof data.output.audio + 'ï¼Œé•¿åº¦: ' + cleanBase64.length, 'info');
                                
                                const byteCharacters = atob(cleanBase64);
                                const byteNumbers = new Array(byteCharacters.length);
                                
                                for (let i = 0; i < byteCharacters.length; i++) {
                                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                                }
                                
                                const byteArray = new Uint8Array(byteNumbers);
                                const audioBlob = new Blob([byteArray], { type: 'audio/mpeg' });
                                const audioUrl = URL.createObjectURL(audioBlob);
                                
                                log('åˆ›å»ºéŸ³é¢‘ Blobï¼Œå¤§å°: ' + audioBlob.size + ' bytes', 'info');
                                
                                const audio = new Audio(audioUrl);
                                
                                audio.onloadeddata = () => log('éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆ', 'info');
                                audio.oncanplay = () => log('éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾', 'info');
                                audio.onplay = () => log('éŸ³é¢‘å¼€å§‹æ’­æ”¾', 'success');
                                audio.onended = () => {
                                    log('éŸ³é¢‘æ’­æ”¾ç»“æŸ', 'success');
                                    URL.revokeObjectURL(audioUrl);
                                };
                                audio.onerror = (e) => {
                                    log('éŸ³é¢‘æ’­æ”¾é”™è¯¯: ' + (audio.error ? audio.error.message : 'æœªçŸ¥é”™è¯¯'), 'error');
                                    URL.revokeObjectURL(audioUrl);
                                };
                                
                                await audio.play();
                                log('Base64 éŸ³é¢‘æ’­æ”¾æˆåŠŸ', 'success');
                            } catch (playError) {
                                log(`Base64 éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${playError.message}`, 'error');
                                showResult('tts-status', 'âš ï¸ TTS è¯·æ±‚æˆåŠŸï¼Œä½† Base64 éŸ³é¢‘æ’­æ”¾å¤±è´¥', 'warning');
                            }
                        } else {
                            showResult('tts-status', 'âš ï¸ TTS è¯·æ±‚æˆåŠŸï¼Œä½†éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒ', 'warning');
                            log('ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: ' + typeof data.output.audio, 'warning');
                        }
                    } else {
                        showResult('tts-status', 'âš ï¸ TTS è¯·æ±‚æˆåŠŸï¼Œä½†å“åº”æ ¼å¼å¼‚å¸¸', 'warning');
                        log('å“åº”æ ¼å¼å¼‚å¸¸ï¼Œæœªæ‰¾åˆ°éŸ³é¢‘æ•°æ®', 'warning');
                    }
                } else {
                    const errorText = await response.text();
                    log(`TTS è¯·æ±‚å¤±è´¥: ${errorText}`, 'error');
                    showResult('tts-status', `âŒ TTS è¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`, 'error');
                }

            } catch (error) {
                log(`TTS è¯·æ±‚å¼‚å¸¸: ${error.message}`, 'error');
                showResult('tts-status', `âŒ TTS è¯·æ±‚å¼‚å¸¸: ${error.message}`, 'error');
            }
        }

        // 5. è¿è¡Œå®Œæ•´æµ‹è¯•
        async function runFullTest() {
            log('=== å¼€å§‹å®Œæ•´æµ‹è¯•æµç¨‹ ===', 'info');
            
            showResult('full-test-status', 'ğŸ”„ æ­£åœ¨è¿è¡Œå®Œæ•´æµ‹è¯•...', 'warning');

            // æ­¥éª¤ 1: éªŒè¯ API å¯†é’¥
            if (!validateApiKey()) {
                showResult('full-test-status', 'âŒ å®Œæ•´æµ‹è¯•å¤±è´¥ï¼šAPI å¯†é’¥æ— æ•ˆ', 'error');
                return;
            }

            // æ­¥éª¤ 2: æµ‹è¯•ç½‘ç»œè¿æ¥
            await testNetworkConnection();
            await new Promise(resolve => setTimeout(resolve, 1000));

            // æ­¥éª¤ 3: æµ‹è¯• API ç«¯ç‚¹
            await testApiEndpoint();
            await new Promise(resolve => setTimeout(resolve, 1000));

            // æ­¥éª¤ 4: æµ‹è¯• TTS è¯·æ±‚
            await testTTSRequest();

            showResult('full-test-status', 'âœ… å®Œæ•´æµ‹è¯•æµç¨‹å®Œæˆï¼Œè¯·æŸ¥çœ‹å„é¡¹æµ‹è¯•ç»“æœ', 'success');
            log('=== å®Œæ•´æµ‹è¯•æµç¨‹ç»“æŸ ===', 'info');
        }

        // é¡µé¢åŠ è½½æ—¶çš„åˆå§‹åŒ–
        window.onload = function() {
            log('DashScope TTS è°ƒè¯•å·¥å…·å·²åŠ è½½', 'info');
            log('è¯·æŒ‰é¡ºåºè¿›è¡Œæµ‹è¯•ï¼Œæˆ–ç›´æ¥è¿è¡Œå®Œæ•´æµ‹è¯•', 'info');
        };
    </script>
</body>
</html>